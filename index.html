<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>격자 폭탄 게임</title>
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <link
      href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css"
      rel="stylesheet"
    />
    <style>
      .cell {
        width: 100%;
        aspect-ratio: 1 / 1;
        font-weight: bold;
        font-size: 1rem;
        transition: background-color 0.2s;
      }
      .bomb {
        background-color: red;
        color: white;
      }
      .obstacle {
        color: white;
      }
      .explode {
        background-color: yellow !important;
        animation: flash 0.4s ease-in-out;
      }
      @keyframes flash {
        0% {
          background-color: yellow;
        }
        50% {
          background-color: orange;
        }
        100% {
          background-color: yellow;
        }
      }
      .dim {
        position: absolute;
        inset: 0;
        background: rgba(0, 0, 0, 0.5);
        z-index: 10;
      }
      .overlay-text {
        z-index: 20;
      }
    </style>
  </head>
  <body
    class="bg-gray-100 min-h-screen flex flex-col items-center justify-start p-4"
  >
    <div class="w-full max-w-md sm:max-w-xl text-center mb-4">
      <h1 class="text-xl font-bold">격자 폭탄 게임</h1>
      <p id="status" class="mt-2 text-sm text-gray-700">턴: 0 / 점수: 0</p>
    </div>

    <div class="relative w-full max-w-md sm:max-w-xl">
      <div id="grid" class="grid grid-cols-8 gap-[1px] bg-black relative"></div>
      <div
        id="overlay"
        class="hidden absolute inset-0 flex flex-col items-center justify-center dim"
      >
        <div class="text-white text-xl font-bold overlay-text mb-4">
          게임 오버
        </div>
        <button
          onclick="location.reload()"
          class="overlay-text bg-white px-4 py-2 rounded shadow"
        >
          다시 시작
        </button>
      </div>
    </div>

    <script>
      const gridSize = 8;
      const grid = [];
      const bombQueue = [];
      let turn = 0;
      let score = 0;
      let gameOver = false;

      function updateStatus() {
        $("#status").text(`턴: ${turn} / 점수: ${score}`);
      }

      function createGrid() {
        const $grid = $("#grid").empty();
        for (let y = 0; y < gridSize; y++) {
          grid[y] = [];
          for (let x = 0; x < gridSize; x++) {
            const $cell = $(
              `<div class="cell bg-white border border-black text-center flex items-center justify-center cursor-pointer" data-x="${x}" data-y="${y}"></div>`
            );
            grid[y][x] = { bomb: null, obstacle: null, el: $cell };
            $grid.append($cell);
          }
        }
      }

      function updateObstacleStyle(cell) {
        cell.el.removeClass((_, className) =>
          (className.match(/bg-gray-[0-9]{3}/g) || []).join(" ")
        );
        if (!cell.obstacle) return;
        const durability = cell.obstacle;
        const level = 200 + Math.min(durability - 1, 7) * 100;
        cell.el.addClass(`obstacle bg-gray-${level}`);
      }

      function placeRandomObstacles(count = 1) {
        let attempts = 0;
        while (count > 0 && attempts < 100) {
          const x = Math.floor(Math.random() * gridSize);
          const y = Math.floor(Math.random() * gridSize);
          const cell = grid[y][x];
          if (!cell.bomb && !cell.obstacle) {
            cell.obstacle = 1;
            cell.el.text(1);
            updateObstacleStyle(cell);
            count--;
          } else if (cell.obstacle) {
            cell.obstacle++;
            cell.el.text(cell.obstacle);
            updateObstacleStyle(cell);
            count--;
          }
          attempts++;
        }
      }

      function placeBomb(x, y) {
        const cell = grid[y][x];
        if (!cell.bomb && !cell.obstacle) {
          const bomb = { x, y, countdown: 3, power: 1, damage: 1 };
          cell.bomb = bomb;
          bombQueue.push(bomb);
          cell.el.text("3").addClass("bomb");
        }
      }

      function updateTurn() {
        turn++;
        const toExplode = [];

        bombQueue.forEach((bomb) => {
          bomb.countdown--;
          if (bomb.countdown <= 0) {
            toExplode.push(bomb);
          } else {
            grid[bomb.y][bomb.x].el.text(bomb.countdown);
          }
        });

        const exploded = new Set();
        while (toExplode.length > 0) {
          const bomb = toExplode.shift();
          const key = `${bomb.x},${bomb.y}`;
          if (exploded.has(key)) continue;
          exploded.add(key);
          explodeBomb(bomb, toExplode);
        }

        for (let i = bombQueue.length - 1; i >= 0; i--) {
          if (bombQueue[i].countdown <= 0) bombQueue.splice(i, 1);
        }

        const newWallCount = Math.floor(turn / 3) + 1;
        placeRandomObstacles(newWallCount);
        updateStatus();
        checkGameOver();
      }

      function explodeBomb(bomb, toExplodeQueue) {
        const { x, y, power, damage } = bomb;
        showExplosion(x, y, damage);
        const cell = grid[y][x];
        cell.el.text("").removeClass("bomb");
        cell.bomb = null;

        const dirs = [
          [1, 0],
          [-1, 0],
          [0, 1],
          [0, -1],
        ];
        dirs.forEach(([dx, dy]) => {
          for (let i = 1; i <= power; i++) {
            const nx = x + dx * i;
            const ny = y + dy * i;
            if (nx < 0 || ny < 0 || nx >= gridSize || ny >= gridSize) break;
            const target = grid[ny][nx];

            showExplosion(nx, ny, damage);

            if (target.obstacle) {
              score += 1;
              target.obstacle--;
              if (target.obstacle <= 0) {
                score += 2;
                target.obstacle = null;
                target.el.text("").removeClass("obstacle");
              } else {
                target.el.text(target.obstacle);
              }
              updateObstacleStyle(target);
              break;
            }

            if (target.bomb && target.bomb.countdown > 0) {
              target.bomb.countdown = 0;
              toExplodeQueue.push({ ...target.bomb, damage: damage + 1 });
            }
          }
        });
      }

      function showExplosion(x, y, damage = 1) {
        const cell = grid[y][x];
        cell.el.addClass("explode").text(damage);
        setTimeout(() => {
          if (!cell.bomb && !cell.obstacle) cell.el.text("");
          cell.el.removeClass("explode");
        }, 300);
      }

      function checkGameOver() {
        const hasEmpty = grid.flat().some((c) => !c.bomb && !c.obstacle);
        if (!hasEmpty) {
          gameOver = true;
          $("#overlay").removeClass("hidden");
        }
      }

      $("#grid").on("click", ".cell", function () {
        if (gameOver) return;

        const x = parseInt($(this).data("x"));
        const y = parseInt($(this).data("y"));
        const cell = grid[y][x];
        if (cell.bomb || cell.obstacle) return;

        placeBomb(x, y);
        updateTurn();
      });

      createGrid();
      placeRandomObstacles(10);
      updateStatus();
    </script>
  </body>
</html>
